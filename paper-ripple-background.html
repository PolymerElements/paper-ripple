<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="paper-clock.html">
<link rel="import" href="paper-ripple-base.html">

<!--
A background ripple, drawn at the center of a container.
-->

<script>
  (function(scope) {
    /**
     * A background ripple, drawn at the center of a container.
     * @param {!PaperClock} clock
     * @param {boolean} isBounded
     * @constructor
     * @extends {Ripple}
     * @suppress {invalidCasts}
     */
    scope.RippleBackground = function(clock, isBounded) {
      Polymer.Ripple.call(/** @type {Ripple} */ (this), clock);

      /** @private {boolean} **/
      this.isBounded_ = isBounded;
    };
    var RippleBackground = scope.RippleBackground;

    RippleBackground.prototype = Object.create(Polymer.Ripple.prototype);
    RippleBackground.prototype.constructor = RippleBackground;


    /**
     * @const {number}
     * @private
     */
    RippleBackground.OPACITY_ENTER_DURATION_MS_ = 600;

    /**
     * The "exit" entrance duration for release.
     * @const {number}
     * @private
     */
    RippleBackground.OPACITY_ENTER_DURATION_FAST_MS_ = 120;

    /**
     * @const {number}
     * @private
     */
    RippleBackground.OPACITY_EXIT_DURATION_MS_ = 480;


    /**
     * Initialize the DOM and draw the initial circle, since its dimensions won't
     * change between draws.
     * @param {!Element} container
     * @param {string} rgbaColor
     * @param {number} radius
     * @param {number} containerWidth
     * @param {number} containerHeight
     */
    RippleBackground.prototype.init =
          function(container, rgbaColor, radius, containerWidth, containerHeight) {
      if (this.container == container) {
        return;
      }

      this.initDom(container, rgbaColor);
      // Draw at the center of the bounding container.
      this.drawCircle(radius, containerWidth / 2, containerHeight / 2);
    };


    /**
     * Linear "pressed" enter based on current opacity.
     */
    RippleBackground.prototype.enter = function() {
      Polymer.Ripple.prototype.enter.call(this);
      this.opacityTween
          .reset()
          .setDuration((1 - this.opacityTween.getValue()) *
              RippleBackground.OPACITY_ENTER_DURATION_MS_)
          .setRange(this.opacityTween.getValue(), 1)
          .setEasing('linear')
          .start();
    };


    /**
     * Finish fading in background, then fade out.
     */
    RippleBackground.prototype.exit = function() {
      Polymer.Ripple.prototype.exit.call(this);
      var exitAnimation = function() {
        this.reset()
            .setDuration(RippleBackground.OPACITY_EXIT_DURATION_MS_)
            .setRange(this.getValue(), 0)
            .setEasing('linear')
            .start();
      }.bind(this.opacityTween);

      var currentOpacity = this.opacityTween.getValue();
      // For bounded, fade in any remaining background before fading out.
      if (this.isBounded_ && currentOpacity < 1) {
        var fastEnterDuration =
            (1 - currentOpacity) * RippleBackground.OPACITY_ENTER_DURATION_FAST_MS_;
        this.opacityTween.reset()
            .setDuration(fastEnterDuration)
            .setRange(currentOpacity, 1)
            .setEasing('linear')
            .onFinish(exitAnimation)
            .start();
      } else {
        exitAnimation();
      }
    };


    /**
     * Draw the background ripple.
     * @param {number} t
     */
    RippleBackground.prototype.draw = function(t) {
      this.updateTweens(t);

      this.element.style.opacity = this.opacityTween.getValue();
    };
  })(Polymer)
</script>
