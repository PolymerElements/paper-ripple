<!--
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="paper-clock.html">
<link rel="import" href="paper-ripple-foreground.html">
<link rel="import" href="paper-ripple-background.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">

<!--
Material design: [Surface reaction](https://www.google.com/design/spec/animation/responsive-interaction.html#responsive-interaction-surface-reaction)

`paper-ripple` provides a visual effect that other paper elements can
use to simulate a rippling effect emanating from the point of contact.  The
effect can be visualized as a concentric circle with motion.

Example:

    <div style="position:relative">
      <paper-ripple></paper-ripple>
    </div>

Note, it's important that the parent container of the ripple be relative position, in order for
the ripple to be displayed properly.

`paper-ripple` listens to "mousedown" and "mouseup" events so it would display ripple
effect when touches on it.  You can also defeat the default behavior and
manually route the down and up actions to the ripple element.  Note that it is
important if you call `downAction()` you will have to make sure to call
`upAction()` so that `paper-ripple` would end the animation loop.

Example:

    <paper-ripple id="ripple" style="pointer-events: none;"></paper-ripple>
    ...
    downAction: function(e) {
      this.$.ripple.downAction({x: e.x, y: e.y});
    },
    upAction: function(e) {
      this.$.ripple.upAction();
    }

Styling ripple effect:

  Use CSS color property to style the ripple:

    paper-ripple {
      --paper-ripple-color: rgba(255, 255, 255, 0.12);
    }

@group Paper Elements
@element paper-ripple
@hero hero.svg
@demo demo/index.html
-->

<dom-module id="paper-ripple">
  <template>
    <style>
     :host {
       /* Default to material gray color. */
       color: var(--paper-ripple-color, rgba(0, 0, 0, 0.06)) !important;
       border-radius: inherit;
       height: 100%;
       left: 0;
       position: absolute;
       top: 0;
       width: 100%;
       -webkit-user-select: none;
       user-select: none;
     }
    </style>
  </template>
</dom-module>
<script>
 (function() {
   /**
    * Fetch the left and top coordinates of the element, relative to the document.
    * @param {!Element} ele
    * @return {!{documentLeft: number, documentTop: number}}
    */
   function getDocumentOffsets(ele) {
     var rect = ele.getBoundingClientRect();
     return {
       documentLeft: window.scrollX + rect.left,
       documentTop: window.scrollY + rect.top
     };
   }

   Polymer({
     is: 'paper-ripple',

     behaviors: [
       Polymer.IronA11yKeysBehavior
     ],

     properties: {
       /**
        * A maximum radius for the ripple, defaults to automatic sizing based
        * on the bounding container.
        */
       maxRadius: {
         type: Number,
         value: 0
       },

       /**
        * Bounded ripples are the usual case, completely contained within another
        * element. Unbounded ripples can draw outside of their immediate container.
        */
       unbounded: {
         type: Boolean,
         value: false,
         observer: '_unboundedChanged'
       },

       /** Whether to allow interaction with the ripple surface. */
       disabled: {
         type: Boolean,
         value: false
       },

       /** Animation clock. */
       clock: {
         type: Object,
         value: function() {
           return new Polymer.PaperClock();
         }
       },

       /** The bounding rectangle for the container. */
       _boundingRect: {
         type: Object,
         value: null
       },

       /** Whether the ripple is currently animating or not. */
       _isAnimating: {
         type: Boolean,
         value: false
       },

       /** Ripple color. */
       _color: {
         type: String,
         value: 'rgba(0, 0, 0, 0.06)'
       },

       /** Cached container radius. */
       _containerRadius: {
         type: Number,
         value: 0
       },

       /** The ripple background. */
       _background: {
         type: Object,
         value: null
       },

       /** An array of foreground ripples still animating. */
       _ripples: {
         type: Array,
         value: function() {
           return [];
         }
       }
     },

     keyBindings: {
       'enter:keydown': '_onEnterKeydown',
       'space:keydown': '_onSpaceKeydown',
       'space:keyup': '_onSpaceKeyup'
     },

     listeners: {
       'up': '_uiUpAction',
       'down': '_uiDownAction'
     },

     get target() {
       var ownerRoot = Polymer.dom(this).getOwnerRoot();
       var target;

       // DOCUMENT_FRAGMENT_NODE
       var parentNode = Polymer.dom(this).parentNode;
       if (parentNode.nodeType == 11) {
         target = ownerRoot.host;
       } else {
         target = parentNode;
       }
       return target;
     },

     ready: function() {
       this._background = new Polymer.RippleBackground(this.clock, !this.unbounded);
     },

     attached: function() {
       this._color = this.getComputedStyleValue('color');

       // Set up a11yKeysBehavior to listen to key events on the target,
       // so that space and enter activate the ripple even if the target doesn't
       // handle key events. The key handlers deal with `noink` themselves.
       this.keyEventTarget = this.target;
     },

     /**
      * Begin the animation runloop, if necessary.
      */
     _startAnimating: function() {
       if (!this._isAnimating) {
         this._isAnimating = true;

         this.clock.tick(this._animationLoop.bind(this));
       }
     },

     /**
      * Core animation loop. Does all drawing for foreground and background
      * ripples.
      */
     _animationLoop: function() {
       var t = this.clock.now();

       this._background.draw(t);

       // Draw and prune foreground ripples.
       var toRemove = [];
       for (var i = 0; i < this._ripples.length; i++) {
         var ripple = this._ripples[i];
         ripple.draw(t);

         if (!ripple.isAnimating()) {
           ripple.remove();
           toRemove.push(i);
         }
       }

       for (var i = toRemove.length - 1; i >= 0; i--) {
         this._ripples.splice(toRemove[i], 1);
       }

       // Should we continue to loop?
       if (this._ripples.length > 0 || this._background.isAnimating()) {
         this.clock.tick(this._animationLoop.bind(this));
       } else {
         this._isAnimating = false;
       }
     },

     /**
      * Recompute measurements and layout.
      */
     layout: function() {
       var target = this.target;

       var rect = target.getBoundingClientRect();
       this._boundingRect = getDocumentOffsets(target);
       this._boundingRect.width = rect.width;
       this._boundingRect.height = rect.height;

       if (this.maxRadius) {
         this._containerRadius = this.maxRadius;
       } else {
         this._containerRadius = this._computeContainerRadius();
       }

       this._background.init(this.root, this._color,
           this._containerRadius, this._boundingRect.width, this._boundingRect.height);
     },

     /**
      * Check whether the coordinates are within the bounds of this ripple container.
      * @param {!{left: number, top: number}} coords
      * @return {boolean}
      */
     _isInBounds: function(coords) {
       return (coords.left >= 0 && coords.left <= this._boundingRect.width &&
         coords.top >= 0 && coords.top <= this._boundingRect.height);
     },


     /**
      * Computes the half diagonal of the container rectangle.
      * @return {number}
      */
     _computeContainerRadius: function() {
       var width = this._boundingRect.width;
       var height = this._boundingRect.height;
       return Math.sqrt(width * width + height * height) / 2;
     },

     /**
      * Returns event coordinates relative to the ripple container.
      * @param {Event=} opt_ev
      * @return {!{left: number, top: number}}
      */
     _getNormalizedEventCoords: function(ev) {
       if (!ev) {
         ev = this._generateCenterEvent();
       } else if ('detail' in ev) {
         ev = ev.detail.sourceEvent;
       }

       var normalizedLeft;
       var normalizedTop;
       // Determine touch point relative to the ripple container.
       if ('pageX' in ev && 'pageY' in ev) {
         normalizedLeft = ev.pageX - this._boundingRect.documentLeft;
         normalizedTop = ev.pageY - this._boundingRect.documentTop;
       } else {
         // Synthetic event, manually specified.
         normalizedLeft = ev.x;
         normalizedTop = ev.y;
       }

       return { left: normalizedLeft, top: normalizedTop };
     },

     /** @return {!{x: number, y: number}} */
     _generateCenterEvent: function() {
       return {
         x: this._boundingRect.width / 2,
         y: this._boundingRect.height / 2
       };
     },

     /**
      * Initiate the up action, exiting all ripples.
      * @param {!Event} ev The up event.
      */
     upAction: function(ev) {
       if (this._ripples.length) {
         this._ripples.forEach(function(each) {
           if (!each.isExiting()) {
             each.exit();
           }
         });
         if (!this._background.isExiting()) {
           this._background.exit();
         }
       }
     },

     /** @param {!Event} ev */
     _uiUpAction: function(ev) {
       if (!this.disabled) {
         this.upAction(ev);
       }
     },

     /**
      * Initiate the down action, creating a new foreground ripple.
      * @param {Event=} opt_ev The down event.
      */
     downAction: function(opt_ev) {
       this.layout();
       var coords = this._getNormalizedEventCoords(opt_ev);

       // Unbounded ripple can visually extend past the parent bounds, but it
       // shouldn't be triggerable outside of it.
       if (!this._isInBounds(coords)) {
         return;
       }

       var ripple = new Polymer.RippleForeground(this.clock, coords.left, coords.top, !this.unbounded);
       ripple.init(
           this.root, this._color,
           this._containerRadius,
           this._boundingRect.width, this._boundingRect.height);

       this._ripples.push(ripple);
       ripple.enter();
       this._background.enter();

       this._startAnimating();
     },

     /** @param {!Event} ev */
     _uiDownAction: function(ev) {
       if (!this.disabled) {
         this.downAction(ev);
       }
     },

     _onEnterKeydown: function() {
       this._uiDownAction();
       this.async(this._uiUpAction, 1);
     },

     _onSpaceKeydown: function() {
       this._uiDownAction();
     },

     _onSpaceKeyup: function() {
       this._uiUpAction();
     },

     /** @param {boolean} unbounded */
     _unboundedChanged: function(unbounded) {
       if (unbounded) {
         this.style.overflow = 'visible';
       } else {
         this.style.overflow = 'hidden';
       }
     }
   });
 }())
</script>
